<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>íŠ¸ë¡  ê²Œì„ - ì„œë¯¼ì¬ì˜ ê²Œì„ëœë“œ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #000428, #004e92);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2.5rem;
            color: #00bfff;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 600px;
            margin-bottom: 20px;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .score, .speed {
            background: rgba(0, 191, 255, 0.1);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #00bfff;
        }

        #gameCanvas {
            border: 4px solid #00bfff;
            border-radius: 10px;
            background: #000;
            box-shadow: 0 0 20px rgba(0, 191, 255, 0.5);
        }

        .controls {
            margin-top: 20px;
            text-align: center;
        }

        .controls h3 {
            margin-bottom: 10px;
            color: #00bfff;
        }

        .controls p {
            margin: 5px 0;
            font-size: 1.1rem;
        }

        .back-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 10px 20px;
            border-radius: 25px;
            text-decoration: none;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .back-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #00bfff;
            text-align: center;
            display: none;
            z-index: 1000;
        }

        .game-over h2 {
            color: #ff0000;
            font-size: 2rem;
            margin-bottom: 20px;
        }

        .restart-btn {
            background: linear-gradient(45deg, #00bfff, #0080ff);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s ease;
        }

        .restart-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 191, 255, 0.4);
        }

        .mode-selector {
            margin-bottom: 20px;
            text-align: center;
        }

        .mode-btn {
            background: rgba(0, 191, 255, 0.2);
            color: #00bfff;
            border: 2px solid #00bfff;
            padding: 10px 20px;
            border-radius: 10px;
            margin: 0 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-btn:hover, .mode-btn.active {
            background: rgba(0, 191, 255, 0.4);
            color: white;
        }
    </style>
</head>
<body>
    <a href="../../index.html" class="back-btn">ğŸ  í™ˆìœ¼ë¡œ</a>
    
    <div class="header">
        <h1>ğŸ’« íŠ¸ë¡  ê²Œì„</h1>
        <p>ë¼ì´íŠ¸ ì‚¬ì´í´ë¡œ ìƒëŒ€ë°©ì„ ê°€ë‘ì„¸ìš”!</p>
    </div>

    <div class="mode-selector">
        <button class="mode-btn active" onclick="setMode('single')">ì‹±ê¸€ í”Œë ˆì´</button>
        <button class="mode-btn" onclick="setMode('multi')">2ì¸ í”Œë ˆì´</button>
    </div>

    <div class="game-info">
        <div class="score">ì ìˆ˜: <span id="score">0</span></div>
        <div class="speed">ì†ë„: <span id="speed">1</span></div>
    </div>

    <canvas id="gameCanvas" width="600" height="600"></canvas>

    <div class="controls">
        <h3>ğŸ® ì¡°ì‘ë²•</h3>
        <div id="singleControls">
            <p>â¬…ï¸â¡ï¸â¬†ï¸â¬‡ï¸ í™”ì‚´í‘œ í‚¤ë¡œ ë°©í–¥ ì „í™˜</p>
            <p>ğŸ’« ìì‹ ì˜ ê¶¤ì ì´ë‚˜ ë²½ì— ë¶€ë”ªíˆì§€ ë§ˆì„¸ìš”!</p>
            <p>ğŸ¤– AIë¥¼ ì´ê¸°ê³  ì‚´ì•„ë‚¨ìœ¼ì„¸ìš”!</p>
        </div>
        <div id="multiControls" style="display: none;">
            <p>í”Œë ˆì´ì–´ 1: â¬…ï¸â¡ï¸â¬†ï¸â¬‡ï¸ í™”ì‚´í‘œ í‚¤</p>
            <p>í”Œë ˆì´ì–´ 2: W, A, S, D í‚¤</p>
            <p>ğŸ’« ìƒëŒ€ë°©ì„ ê°€ë‘ê³  ì‚´ì•„ë‚¨ìœ¼ì„¸ìš”!</p>
        </div>
    </div>

    <div class="game-over" id="gameOver">
        <h2 id="gameOverTitle">ê²Œì„ ì˜¤ë²„!</h2>
        <p id="gameOverMessage">ìµœì¢… ì ìˆ˜: <span id="finalScore">0</span></p>
        <button class="restart-btn" onclick="restartGame()">ë‹¤ì‹œ ì‹œì‘</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ê²Œì„ ìƒíƒœ
        let score = 0;
        let speed = 1;
        let gameRunning = false;
        let gameMode = 'single'; // 'single' ë˜ëŠ” 'multi'

        // ê·¸ë¦¬ë“œ ì„¤ì •
        const GRID_SIZE = 10;
        const COLS = canvas.width / GRID_SIZE;
        const ROWS = canvas.height / GRID_SIZE;

        // í”Œë ˆì´ì–´ë“¤
        let players = [];
        let trails = [];

        // í‚¤ë³´ë“œ ì…ë ¥
        const keys = {};
        
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            handleKeyPress(e.key);
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // ê²Œì„ ëª¨ë“œ ì„¤ì •
        function setMode(mode) {
            gameMode = mode;
            
            // ë²„íŠ¼ í™œì„±í™” ìƒíƒœ ë³€ê²½
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // ì¡°ì‘ë²• í‘œì‹œ ë³€ê²½
            if (mode === 'single') {
                document.getElementById('singleControls').style.display = 'block';
                document.getElementById('multiControls').style.display = 'none';
            } else {
                document.getElementById('singleControls').style.display = 'none';
                document.getElementById('multiControls').style.display = 'block';
            }
            
            if (!gameRunning) {
                initGame();
            }
        }

        // í”Œë ˆì´ì–´ ì´ˆê¸°í™”
        function initPlayers() {
            players = [];
            trails = [];
            
            if (gameMode === 'single') {
                // í”Œë ˆì´ì–´
                players.push({
                    x: Math.floor(COLS / 4),
                    y: Math.floor(ROWS / 2),
                    direction: 0, // 0: ì˜¤ë¥¸ìª½, 1: ì•„ë˜, 2: ì™¼ìª½, 3: ìœ„
                    color: '#00bfff',
                    alive: true,
                    isAI: false,
                    name: 'Player'
                });
                
                // AI
                players.push({
                    x: Math.floor(COLS * 3 / 4),
                    y: Math.floor(ROWS / 2),
                    direction: 2,
                    color: '#ff6600',
                    alive: true,
                    isAI: true,
                    name: 'AI',
                    aiTimer: 0
                });
            } else {
                // í”Œë ˆì´ì–´ 1
                players.push({
                    x: Math.floor(COLS / 4),
                    y: Math.floor(ROWS / 2),
                    direction: 0,
                    color: '#00bfff',
                    alive: true,
                    isAI: false,
                    name: 'Player 1'
                });
                
                // í”Œë ˆì´ì–´ 2
                players.push({
                    x: Math.floor(COLS * 3 / 4),
                    y: Math.floor(ROWS / 2),
                    direction: 2,
                    color: '#ff6600',
                    alive: true,
                    isAI: false,
                    name: 'Player 2'
                });
            }
            
            // ê¶¤ì  ì´ˆê¸°í™”
            players.forEach((player, index) => {
                trails[index] = [];
                trails[index].push({ x: player.x, y: player.y });
            });
        }

        // í‚¤ ì…ë ¥ ì²˜ë¦¬
        function handleKeyPress(key) {
            if (!gameRunning) {
                if (key === ' ') {
                    startGame();
                }
                return;
            }
            
            // í”Œë ˆì´ì–´ 1 (í™”ì‚´í‘œ í‚¤)
            if (players[0] && players[0].alive) {
                switch(key) {
                    case 'ArrowLeft':
                        if (players[0].direction !== 0) players[0].direction = 2;
                        break;
                    case 'ArrowRight':
                        if (players[0].direction !== 2) players[0].direction = 0;
                        break;
                    case 'ArrowUp':
                        if (players[0].direction !== 1) players[0].direction = 3;
                        break;
                    case 'ArrowDown':
                        if (players[0].direction !== 3) players[0].direction = 1;
                        break;
                }
            }
            
            // í”Œë ˆì´ì–´ 2 (WASD)
            if (gameMode === 'multi' && players[1] && players[1].alive) {
                switch(key.toLowerCase()) {
                    case 'a':
                        if (players[1].direction !== 0) players[1].direction = 2;
                        break;
                    case 'd':
                        if (players[1].direction !== 2) players[1].direction = 0;
                        break;
                    case 'w':
                        if (players[1].direction !== 1) players[1].direction = 3;
                        break;
                    case 's':
                        if (players[1].direction !== 3) players[1].direction = 1;
                        break;
                }
            }
        }

        // AI ì—…ë°ì´íŠ¸
        function updateAI(player, index) {
            player.aiTimer++;
            if (player.aiTimer < 5) return; // AI ë°˜ì‘ ì†ë„ ì¡°ì ˆ
            
            player.aiTimer = 0;
            
            const directions = [
                { x: 1, y: 0 },  // ì˜¤ë¥¸ìª½
                { x: 0, y: 1 },  // ì•„ë˜
                { x: -1, y: 0 }, // ì™¼ìª½
                { x: 0, y: -1 }  // ìœ„
            ];
            
            // í˜„ì¬ ë°©í–¥ìœ¼ë¡œ ê³„ì† ê°ˆ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸
            const currentDir = directions[player.direction];
            const nextX = player.x + currentDir.x;
            const nextY = player.y + currentDir.y;
            
            if (isValidMove(nextX, nextY)) {
                return; // ê³„ì† ì§ì§„
            }
            
            // ë°©í–¥ ì „í™˜ í•„ìš”
            const possibleDirections = [];
            
            for (let i = 0; i < 4; i++) {
                if (i === (player.direction + 2) % 4) continue; // ë’¤ë¡œ ê°€ê¸° ê¸ˆì§€
                
                const dir = directions[i];
                const testX = player.x + dir.x;
                const testY = player.y + dir.y;
                
                if (isValidMove(testX, testY)) {
                    // ë” ë©€ë¦¬ ê°ˆ ìˆ˜ ìˆëŠ” ë°©í–¥ì¸ì§€ í™•ì¸
                    let distance = 0;
                    let checkX = testX;
                    let checkY = testY;
                    
                    while (isValidMove(checkX, checkY) && distance < 10) {
                        checkX += dir.x;
                        checkY += dir.y;
                        distance++;
                    }
                    
                    possibleDirections.push({ direction: i, distance: distance });
                }
            }
            
            if (possibleDirections.length > 0) {
                // ê°€ì¥ ë©€ë¦¬ ê°ˆ ìˆ˜ ìˆëŠ” ë°©í–¥ ì„ íƒ
                possibleDirections.sort((a, b) => b.distance - a.distance);
                player.direction = possibleDirections[0].direction;
            }
        }

        // ìœ íš¨í•œ ì´ë™ì¸ì§€ í™•ì¸
        function isValidMove(x, y) {
            // ë²½ ì¶©ëŒ
            if (x < 0 || x >= COLS || y < 0 || y >= ROWS) {
                return false;
            }
            
            // ê¶¤ì  ì¶©ëŒ
            for (let trail of trails) {
                for (let segment of trail) {
                    if (segment.x === x && segment.y === y) {
                        return false;
                    }
                }
            }
            
            return true;
        }

        // í”Œë ˆì´ì–´ ì—…ë°ì´íŠ¸
        function updatePlayers() {
            const directions = [
                { x: 1, y: 0 },  // ì˜¤ë¥¸ìª½
                { x: 0, y: 1 },  // ì•„ë˜
                { x: -1, y: 0 }, // ì™¼ìª½
                { x: 0, y: -1 }  // ìœ„
            ];
            
            players.forEach((player, index) => {
                if (!player.alive) return;
                
                // AI ì—…ë°ì´íŠ¸
                if (player.isAI) {
                    updateAI(player, index);
                }
                
                // ì´ë™
                const dir = directions[player.direction];
                const newX = player.x + dir.x;
                const newY = player.y + dir.y;
                
                // ì¶©ëŒ ì²´í¬
                if (!isValidMove(newX, newY)) {
                    player.alive = false;
                    
                    if (gameMode === 'single' && !player.isAI) {
                        // ì‹±ê¸€ í”Œë ˆì´ì—ì„œ í”Œë ˆì´ì–´ê°€ ì£½ìœ¼ë©´ ê²Œì„ ì˜¤ë²„
                        gameOver('Game Over!', `ì ìˆ˜: ${score}`);
                    }
                    return;
                }
                
                // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                player.x = newX;
                player.y = newY;
                
                // ê¶¤ì  ì¶”ê°€
                trails[index].push({ x: newX, y: newY });
                
                // ì ìˆ˜ ì¦ê°€ (ì‹±ê¸€ í”Œë ˆì´ì–´ë§Œ)
                if (gameMode === 'single' && !player.isAI) {
                    score++;
                    updateScore();
                    
                    // ì†ë„ ì¦ê°€
                    if (score % 100 === 0) {
                        speed++;
                        updateSpeed();
                    }
                }
            });
            
            // ê²Œì„ ì¢…ë£Œ ì²´í¬
            const alivePlayers = players.filter(p => p.alive);
            
            if (alivePlayers.length === 0) {
                gameOver('ë¬´ìŠ¹ë¶€!', 'ëª¨ë“  í”Œë ˆì´ì–´ê°€ ë™ì‹œì— ì¶©ëŒí–ˆìŠµë‹ˆë‹¤!');
            } else if (alivePlayers.length === 1) {
                if (gameMode === 'multi') {
                    gameOver(`${alivePlayers[0].name} ìŠ¹ë¦¬!`, `${alivePlayers[0].name}ì´(ê°€) ì´ê²¼ìŠµë‹ˆë‹¤!`);
                } else if (alivePlayers[0].isAI) {
                    gameOver('AI ìŠ¹ë¦¬!', `ì ìˆ˜: ${score}`);
                }
            }
        }

        // ê·¸ë¦¬ê¸° í•¨ìˆ˜ë“¤
        function drawGrid() {
            ctx.strokeStyle = '#003366';
            ctx.lineWidth = 1;
            
            for (let x = 0; x <= COLS; x++) {
                ctx.beginPath();
                ctx.moveTo(x * GRID_SIZE, 0);
                ctx.lineTo(x * GRID_SIZE, canvas.height);
                ctx.stroke();
            }
            
            for (let y = 0; y <= ROWS; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * GRID_SIZE);
                ctx.lineTo(canvas.width, y * GRID_SIZE);
                ctx.stroke();
            }
        }

        function drawPlayers() {
            players.forEach((player, index) => {
                if (!player.alive) return;
                
                // í”Œë ˆì´ì–´ í—¤ë“œ
                ctx.fillStyle = player.color;
                ctx.fillRect(
                    player.x * GRID_SIZE + 1,
                    player.y * GRID_SIZE + 1,
                    GRID_SIZE - 2,
                    GRID_SIZE - 2
                );
                
                // ê¶¤ì 
                ctx.fillStyle = player.color;
                ctx.globalAlpha = 0.7;
                
                trails[index].forEach(segment => {
                    ctx.fillRect(
                        segment.x * GRID_SIZE + 1,
                        segment.y * GRID_SIZE + 1,
                        GRID_SIZE - 2,
                        GRID_SIZE - 2
                    );
                });
                
                ctx.globalAlpha = 1;
            });
        }

        function drawStartScreen() {
            ctx.fillStyle = '#00bfff';
            ctx.font = '24px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('TRON', canvas.width / 2, canvas.height / 2 - 50);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = '16px monospace';
            ctx.fillText('ìŠ¤í˜ì´ìŠ¤ë°”ë¥¼ ëˆŒëŸ¬ ì‹œì‘', canvas.width / 2, canvas.height / 2);
            
            if (gameMode === 'single') {
                ctx.fillText('AIì™€ ëŒ€ê²°í•˜ì„¸ìš”!', canvas.width / 2, canvas.height / 2 + 30);
            } else {
                ctx.fillText('2ì¸ ëŒ€ì „ ëª¨ë“œ', canvas.width / 2, canvas.height / 2 + 30);
            }
        }

        // ê²Œì„ ì‹œì‘
        function startGame() {
            gameRunning = true;
            score = 0;
            speed = 1;
            updateScore();
            updateSpeed();
            initPlayers();
        }

        // UI ì—…ë°ì´íŠ¸
        function updateScore() {
            document.getElementById('score').textContent = score;
        }

        function updateSpeed() {
            document.getElementById('speed').textContent = speed;
        }

        // ê²Œì„ ì˜¤ë²„
        function gameOver(title, message) {
            gameRunning = false;
            document.getElementById('gameOverTitle').textContent = title;
            document.getElementById('gameOverMessage').textContent = message;
            document.getElementById('gameOver').style.display = 'block';
        }

        // ê²Œì„ ì¬ì‹œì‘
        function restartGame() {
            gameRunning = false;
            document.getElementById('gameOver').style.display = 'none';
            initGame();
        }

        // ê²Œì„ ì´ˆê¸°í™”
        function initGame() {
            score = 0;
            speed = 1;
            updateScore();
            updateSpeed();
            initPlayers();
        }

        // ê²Œì„ ë£¨í”„
        let lastTime = 0;
        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            const frameRate = 1000 / (5 + (10 - speed)); // ì†ë„ì— ë”°ë¥¸ í”„ë ˆì„ ë ˆì´íŠ¸
            
            if (deltaTime >= frameRate) {
                // í™”ë©´ ì§€ìš°ê¸°
                ctx.fillStyle = '#000011';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                drawGrid();
                
                if (gameRunning) {
                    updatePlayers();
                    drawPlayers();
                } else {
                    drawStartScreen();
                }
                
                lastTime = currentTime;
            }
            
            requestAnimationFrame(gameLoop);
        }

        // ê²Œì„ ì‹œì‘
        initGame();
        gameLoop(0);
    </script>
</body>
</html>