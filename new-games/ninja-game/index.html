<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ¥· ë‹Œì ê²Œì„</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #2C3E50, #34495E);
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: white;
        }
        
        .game-container {
            text-align: center;
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #E74C3C;
        }
        
        canvas {
            border: 3px solid #C0392B;
            border-radius: 10px;
            background: linear-gradient(180deg, #34495E 0%, #2C3E50 50%, #1A252F 100%);
        }
        
        .ui {
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .stat {
            background: rgba(231, 76, 60, 0.8);
            padding: 8px 15px;
            border-radius: 20px;
            margin: 5px;
            font-weight: bold;
        }
        
        .controls {
            margin-top: 15px;
            font-size: 14px;
            color: #ccc;
        }
        
        .abilities {
            margin: 10px 0;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .ability-btn {
            background: #8E44AD;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 15px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .ability-btn:hover {
            background: #9B59B6;
            transform: scale(1.05);
        }
        
        .ability-btn:disabled {
            background: #555;
            cursor: not-allowed;
        }
        
        .stealth-indicator {
            margin: 10px 0;
            font-size: 16px;
            font-weight: bold;
        }
        
        .stealth-indicator.hidden {
            color: #3498DB;
        }
        
        .stealth-indicator.visible {
            color: #E74C3C;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>ğŸ¥· ë‹Œì ê²Œì„</h1>
        
        <div class="ui">
            <div class="stat">â¤ï¸ ì²´ë ¥: <span id="health">100</span></div>
            <div class="stat">â­ ì ìˆ˜: <span id="score">0</span></div>
            <div class="stat">ğŸ¯ ì  ì²˜ì¹˜: <span id="enemiesKilled">0</span></div>
            <div class="stat">ğŸ’ ìˆ˜ë¦¬ê²€: <span id="shurikens">10</span></div>
        </div>
        
        <div class="stealth-indicator hidden" id="stealthIndicator">
            ğŸŒ™ ì€ì‹  ìƒíƒœ
        </div>
        
        <div class="abilities">
            <button class="ability-btn" onclick="useAbility('dash')" id="dashBtn">âš¡ ëŒ€ì‰¬ (E)</button>
            <button class="ability-btn" onclick="useAbility('stealth')" id="stealthBtn">ğŸ‘» ì€ì‹  (Q)</button>
            <button class="ability-btn" onclick="useAbility('wallJump')" id="wallJumpBtn">ğŸ§— ë²½íƒ€ê¸° (W)</button>
        </div>
        
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div class="controls">
            <p>ğŸ® ì¡°ì‘ë²•: WASDë¡œ ì´ë™, ë§ˆìš°ìŠ¤ í´ë¦­ìœ¼ë¡œ ìˆ˜ë¦¬ê²€ ë˜ì§€ê¸°, ìŠ¤í˜ì´ìŠ¤ë°”ë¡œ ì í”„</p>
            <p>ğŸ¥· ë‹Œì ê¸°ìˆ : E(ëŒ€ì‰¬), Q(ì€ì‹ ), W(ë²½íƒ€ê¸°) - ì ë“¤ì„ í”¼í•˜ë©° ì„ë¬´ë¥¼ ì™„ìˆ˜í•˜ì„¸ìš”!</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // ê²Œì„ ìƒíƒœ
        let gameState = {
            health: 100,
            score: 0,
            enemiesKilled: 0,
            shurikens: 10,
            isStealthed: false,
            stealthTime: 0
        };
        
        // ë‹Œì í”Œë ˆì´ì–´
        const ninja = {
            x: 100,
            y: 400,
            width: 20,
            height: 30,
            vx: 0,
            vy: 0,
            speed: 4,
            jumpPower: 15,
            onGround: false,
            onWall: false,
            facing: 1, // 1: ì˜¤ë¥¸ìª½, -1: ì™¼ìª½
            dashCooldown: 0,
            stealthCooldown: 0,
            wallJumpCooldown: 0
        };
        
        // ê²Œì„ ê°ì²´ë“¤
        let enemies = [];
        let shurikens = [];
        let particles = [];
        let platforms = [];
        let walls = [];
        
        // í‚¤ ì…ë ¥
        const keys = {};
        let mouseX = 0, mouseY = 0;
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            
            // ëŠ¥ë ¥ ë‹¨ì¶•í‚¤
            if (e.key.toLowerCase() === 'e') useAbility('dash');
            if (e.key.toLowerCase() === 'q') useAbility('stealth');
            if (e.key.toLowerCase() === 'w') useAbility('wallJump');
        });
        document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });
        
        canvas.addEventListener('click', throwShuriken);
        
        // ë ˆë²¨ ìƒì„±
        function createLevel() {
            platforms = [
                { x: 0, y: canvas.height - 20, width: canvas.width, height: 20 }, // ë°”ë‹¥
                { x: 200, y: 450, width: 150, height: 20 },
                { x: 400, y: 350, width: 150, height: 20 },
                { x: 600, y: 250, width: 150, height: 20 },
                { x: 100, y: 200, width: 100, height: 20 },
                { x: 500, y: 150, width: 100, height: 20 }
            ];
            
            walls = [
                { x: 0, y: 0, width: 20, height: canvas.height },
                { x: canvas.width - 20, y: 0, width: 20, height: canvas.height },
                { x: 300, y: 300, width: 20, height: 150 },
                { x: 550, y: 100, width: 20, height: 200 }
            ];
            
            // ì  ìƒì„±
            enemies = [
                { x: 250, y: 420, width: 25, height: 25, vx: 1, health: 50, maxHealth: 50, patrol: { start: 200, end: 350 }, type: 'guard' },
                { x: 450, y: 320, width: 25, height: 25, vx: -1, health: 50, maxHealth: 50, patrol: { start: 400, end: 550 }, type: 'guard' },
                { x: 650, y: 220, width: 25, height: 25, vx: 1, health: 75, maxHealth: 75, patrol: { start: 600, end: 750 }, type: 'samurai' },
                { x: 150, y: 170, width: 20, height: 20, vx: 0, health: 30, maxHealth: 30, alertRadius: 100, type: 'archer' }
            ];
        }
        
        // ìˆ˜ë¦¬ê²€ ë˜ì§€ê¸°
        function throwShuriken() {
            if (gameState.shurikens <= 0) return;
            
            gameState.shurikens--;
            
            const angle = Math.atan2(mouseY - ninja.y, mouseX - ninja.x);
            const speed = 12;
            
            shurikens.push({
                x: ninja.x + ninja.width / 2,
                y: ninja.y + ninja.height / 2,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                rotation: 0,
                damage: 25
            });
        }
        
        // ëŠ¥ë ¥ ì‚¬ìš©
        function useAbility(ability) {
            switch(ability) {
                case 'dash':
                    if (ninja.dashCooldown <= 0) {
                        ninja.vx = ninja.facing * 15;
                        ninja.dashCooldown = 120; // 2ì´ˆ
                        createParticles(ninja.x, ninja.y, '#3498DB', 8);
                    }
                    break;
                    
                case 'stealth':
                    if (ninja.stealthCooldown <= 0) {
                        gameState.isStealthed = true;
                        gameState.stealthTime = 180; // 3ì´ˆ
                        ninja.stealthCooldown = 600; // 10ì´ˆ
                        updateStealthIndicator();
                    }
                    break;
                    
                case 'wallJump':
                    if (ninja.wallJumpCooldown <= 0 && ninja.onWall) {
                        ninja.vy = -ninja.jumpPower;
                        ninja.vx = -ninja.facing * 8;
                        ninja.wallJumpCooldown = 60; // 1ì´ˆ
                        createParticles(ninja.x, ninja.y, '#E67E22', 5);
                    }
                    break;
            }
        }
        
        // ì€ì‹  ìƒíƒœ í‘œì‹œ ì—…ë°ì´íŠ¸
        function updateStealthIndicator() {
            const indicator = document.getElementById('stealthIndicator');
            if (gameState.isStealthed) {
                indicator.className = 'stealth-indicator hidden';
                indicator.textContent = 'ğŸŒ™ ì€ì‹  ìƒíƒœ';
            } else {
                indicator.className = 'stealth-indicator visible';
                indicator.textContent = 'ğŸ‘ï¸ ë°œê°ë¨';
            }
        }
        
        // íŒŒí‹°í´ ìƒì„±
        function createParticles(x, y, color, count = 5) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: 30,
                    maxLife: 30,
                    color: color,
                    size: Math.random() * 4 + 2
                });
            }
        }
        
        // ì¶©ëŒ ê°ì§€
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }
        
        // ì—…ë°ì´íŠ¸
        function update() {
            // ë‹Œì ì´ë™
            if (keys['a'] || keys['ã…']) {
                ninja.vx = -ninja.speed;
                ninja.facing = -1;
            } else if (keys['d'] || keys['ã…‡']) {
                ninja.vx = ninja.speed;
                ninja.facing = 1;
            } else {
                ninja.vx *= 0.8; // ë§ˆì°°
            }
            
            // ì í”„
            if ((keys[' '] || keys['w'] || keys['ã…ˆ']) && ninja.onGround) {
                ninja.vy = -ninja.jumpPower;
                ninja.onGround = false;
            }
            
            // ì¤‘ë ¥
            ninja.vy += 0.8;
            
            // ë‹Œì ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            ninja.x += ninja.vx;
            ninja.y += ninja.vy;
            
            // í”Œë«í¼ ì¶©ëŒ
            ninja.onGround = false;
            ninja.onWall = false;
            
            platforms.forEach(platform => {
                if (checkCollision(ninja, platform)) {
                    if (ninja.vy > 0 && ninja.y < platform.y) {
                        ninja.y = platform.y - ninja.height;
                        ninja.vy = 0;
                        ninja.onGround = true;
                    }
                }
            });
            
            // ë²½ ì¶©ëŒ
            walls.forEach(wall => {
                if (checkCollision(ninja, wall)) {
                    if (ninja.vx > 0) {
                        ninja.x = wall.x - ninja.width;
                        ninja.onWall = true;
                    } else if (ninja.vx < 0) {
                        ninja.x = wall.x + wall.width;
                        ninja.onWall = true;
                    }
                    ninja.vx = 0;
                }
            });
            
            // ê²½ê³„ ì²´í¬
            if (ninja.x < 0) ninja.x = 0;
            if (ninja.x + ninja.width > canvas.width) ninja.x = canvas.width - ninja.width;
            if (ninja.y > canvas.height) {
                ninja.y = 100;
                ninja.x = 100;
                gameState.health -= 20;
            }
            
            // ì  ì—…ë°ì´íŠ¸
            enemies.forEach((enemy, enemyIndex) => {
                if (enemy.type === 'guard' || enemy.type === 'samurai') {
                    // ìˆœì°°
                    enemy.x += enemy.vx;
                    if (enemy.x <= enemy.patrol.start || enemy.x >= enemy.patrol.end) {
                        enemy.vx *= -1;
                    }
                } else if (enemy.type === 'archer') {
                    // ë‹Œì ê°ì§€
                    const distance = Math.sqrt((ninja.x - enemy.x) ** 2 + (ninja.y - enemy.y) ** 2);
                    if (distance < enemy.alertRadius && !gameState.isStealthed) {
                        // í™”ì‚´ ë°œì‚¬ (ê°„ë‹¨íˆ ìˆ˜ë¦¬ê²€ìœ¼ë¡œ ëŒ€ì²´)
                        if (Math.random() < 0.02) {
                            const angle = Math.atan2(ninja.y - enemy.y, ninja.x - enemy.x);
                            shurikens.push({
                                x: enemy.x,
                                y: enemy.y,
                                vx: Math.cos(angle) * 6,
                                vy: Math.sin(angle) * 6,
                                rotation: 0,
                                damage: 15,
                                isEnemyProjectile: true
                            });
                        }
                    }
                }
                
                // ë‹Œìì™€ ì  ì¶©ëŒ
                if (checkCollision(ninja, enemy) && !gameState.isStealthed) {
                    gameState.health -= 1;
                    createParticles(ninja.x, ninja.y, '#E74C3C');
                }
            });
            
            // ìˆ˜ë¦¬ê²€ ì—…ë°ì´íŠ¸
            shurikens.forEach((shuriken, sIndex) => {
                shuriken.x += shuriken.vx;
                shuriken.y += shuriken.vy;
                shuriken.rotation += 0.3;
                
                // ê²½ê³„ ì²´í¬
                if (shuriken.x < 0 || shuriken.x > canvas.width || 
                    shuriken.y < 0 || shuriken.y > canvas.height) {
                    shurikens.splice(sIndex, 1);
                    return;
                }
                
                // í”Œë«í¼ ì¶©ëŒ
                platforms.forEach(platform => {
                    if (checkCollision(shuriken, platform)) {
                        shurikens.splice(sIndex, 1);
                        createParticles(shuriken.x, shuriken.y, '#95A5A6');
                    }
                });
                
                // ì ê³¼ ì¶©ëŒ (í”Œë ˆì´ì–´ ìˆ˜ë¦¬ê²€ë§Œ)
                if (!shuriken.isEnemyProjectile) {
                    enemies.forEach((enemy, eIndex) => {
                        if (checkCollision(shuriken, enemy)) {
                            enemy.health -= shuriken.damage;
                            shurikens.splice(sIndex, 1);
                            createParticles(enemy.x, enemy.y, '#E74C3C');
                            
                            if (enemy.health <= 0) {
                                enemies.splice(eIndex, 1);
                                gameState.enemiesKilled++;
                                gameState.score += 100;
                                gameState.shurikens += 2; // ë³´ìƒ
                            }
                        }
                    });
                } else {
                    // ì  ìˆ˜ë¦¬ê²€ê³¼ ë‹Œì ì¶©ëŒ
                    if (checkCollision(shuriken, ninja)) {
                        gameState.health -= shuriken.damage;
                        shurikens.splice(sIndex, 1);
                        createParticles(ninja.x, ninja.y, '#E74C3C');
                    }
                }
            });
            
            // íŒŒí‹°í´ ì—…ë°ì´íŠ¸
            particles.forEach((particle, pIndex) => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vx *= 0.95;
                particle.vy *= 0.95;
                particle.life--;
                
                if (particle.life <= 0) {
                    particles.splice(pIndex, 1);
                }
            });
            
            // ì¿¨ë‹¤ìš´ ì—…ë°ì´íŠ¸
            if (ninja.dashCooldown > 0) ninja.dashCooldown--;
            if (ninja.stealthCooldown > 0) ninja.stealthCooldown--;
            if (ninja.wallJumpCooldown > 0) ninja.wallJumpCooldown--;
            
            // ì€ì‹  ì‹œê°„ ì—…ë°ì´íŠ¸
            if (gameState.stealthTime > 0) {
                gameState.stealthTime--;
                if (gameState.stealthTime <= 0) {
                    gameState.isStealthed = false;
                    updateStealthIndicator();
                }
            }
            
            // ëŠ¥ë ¥ ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
            document.getElementById('dashBtn').disabled = ninja.dashCooldown > 0;
            document.getElementById('stealthBtn').disabled = ninja.stealthCooldown > 0;
            document.getElementById('wallJumpBtn').disabled = ninja.wallJumpCooldown > 0 || !ninja.onWall;
            
            // ê²Œì„ ì˜¤ë²„ ì²´í¬
            if (gameState.health <= 0) {
                alert(`ê²Œì„ ì˜¤ë²„! ìµœì¢… ì ìˆ˜: ${gameState.score}`);
                location.reload();
            }
            
            // ìŠ¹ë¦¬ ì¡°ê±´ (ëª¨ë“  ì  ì²˜ì¹˜)
            if (enemies.length === 0) {
                alert(`ë¯¸ì…˜ ì™„ë£Œ! ëª¨ë“  ì ì„ ì²˜ì¹˜í–ˆìŠµë‹ˆë‹¤!\nìµœì¢… ì ìˆ˜: ${gameState.score}`);
                createLevel(); // ìƒˆ ë ˆë²¨ ìƒì„±
            }
            
            updateUI();
        }
        
        // ë Œë”ë§
        function render() {
            // ë°°ê²½
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#34495E');
            gradient.addColorStop(0.5, '#2C3E50');
            gradient.addColorStop(1, '#1A252F');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ë‹¬ê³¼ ë³„ë“¤
            ctx.fillStyle = '#F39C12';
            ctx.beginPath();
            ctx.arc(700, 80, 30, 0, Math.PI * 2);
            ctx.fill();
            
            for (let i = 0; i < 20; i++) {
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(Math.random() * canvas.width, Math.random() * 200, 1, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // í”Œë«í¼
            ctx.fillStyle = '#7F8C8D';
            platforms.forEach(platform => {
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
            });
            
            // ë²½
            ctx.fillStyle = '#95A5A6';
            walls.forEach(wall => {
                ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
            });
            
            // ë‹Œì
            ctx.save();
            if (gameState.isStealthed) {
                ctx.globalAlpha = 0.5;
            }
            ctx.fillStyle = '#2C3E50';
            ctx.fillRect(ninja.x, ninja.y, ninja.width, ninja.height);
            
            // ë‹Œì ì–¼êµ´
            ctx.fillStyle = '#E8E8E8';
            ctx.fillRect(ninja.x + 2, ninja.y + 2, ninja.width - 4, 8);
            
            // ë‹Œì ëˆˆ
            ctx.fillStyle = '#E74C3C';
            ctx.fillRect(ninja.x + 4, ninja.y + 4, 3, 2);
            ctx.fillRect(ninja.x + ninja.width - 7, ninja.y + 4, 3, 2);
            ctx.restore();
            
            // ì ë“¤
            enemies.forEach(enemy => {
                let color = '#8E44AD';
                if (enemy.type === 'samurai') color = '#E74C3C';
                if (enemy.type === 'archer') color = '#27AE60';
                
                ctx.fillStyle = color;
                ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                
                // ì²´ë ¥ë°”
                const barWidth = enemy.width;
                const barHeight = 4;
                const healthPercent = enemy.health / enemy.maxHealth;
                
                ctx.fillStyle = '#E74C3C';
                ctx.fillRect(enemy.x, enemy.y - 8, barWidth, barHeight);
                ctx.fillStyle = '#27AE60';
                ctx.fillRect(enemy.x, enemy.y - 8, barWidth * healthPercent, barHeight);
                
                // ê°ì§€ ë²”ìœ„ (ê¶ìˆ˜)
                if (enemy.type === 'archer' && !gameState.isStealthed) {
                    ctx.strokeStyle = 'rgba(231, 76, 60, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.alertRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });
            
            // ìˆ˜ë¦¬ê²€
            shurikens.forEach(shuriken => {
                ctx.save();
                ctx.translate(shuriken.x, shuriken.y);
                ctx.rotate(shuriken.rotation);
                
                ctx.fillStyle = shuriken.isEnemyProjectile ? '#E74C3C' : '#BDC3C7';
                ctx.beginPath();
                ctx.moveTo(-6, 0);
                ctx.lineTo(0, -6);
                ctx.lineTo(6, 0);
                ctx.lineTo(0, 6);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            });
            
            // íŒŒí‹°í´
            particles.forEach(particle => {
                const alpha = particle.life / particle.maxLife;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }
        
        // UI ì—…ë°ì´íŠ¸
        function updateUI() {
            document.getElementById('health').textContent = Math.max(0, gameState.health);
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('enemiesKilled').textContent = gameState.enemiesKilled;
            document.getElementById('shurikens').textContent = gameState.shurikens;
        }
        
        // ê²Œì„ ë£¨í”„
        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }
        
        // ê²Œì„ ì‹œì‘
        createLevel();
        updateStealthIndicator();
        gameLoop();
    </script>
</body>
</html>