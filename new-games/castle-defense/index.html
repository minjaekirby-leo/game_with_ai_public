<!DOCTYPE html>
<html>
<head>
    <title>ì„± ë°©ì–´ ê²Œì„</title>
    
    <!-- Google Analytics -->
    <script src="../../analytics.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Comic Sans MS', cursive;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            text-align: center;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        h1 {
            font-size: 3rem;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            margin-bottom: 20px;
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from { text-shadow: 0 0 20px rgba(255, 255, 255, 0.5); }
            to { text-shadow: 0 0 30px rgba(255, 255, 255, 0.8); }
        }
        
        .game-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 30px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        canvas {
            border: 4px solid #fff;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            background: linear-gradient(180deg, #87CEEB 0%, #90EE90 100%);
            cursor: crosshair;
        }
        
        .game-info {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            min-width: 200px;
        }
        
        .info-item {
            margin: 15px 0;
            font-size: 1.2rem;
            font-weight: bold;
        }
        
        .tower-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 20px 0;
        }
        
        .tower-btn {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            padding: 10px;
            border-radius: 10px;
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .tower-btn:hover {
            transform: scale(1.05);
        }
        
        .tower-btn.selected {
            background: linear-gradient(45deg, #f39c12, #e67e22);
        }
        
        button {
            background: linear-gradient(45deg, #2c3e50, #34495e);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        .instructions {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin: 20px auto;
            max-width: 600px;
            backdrop-filter: blur(5px);
        }
        
        #secretMessage {
            display: none;
            background: linear-gradient(45deg, #ff6b6b, #ffd700);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 1rem;
            font-weight: bold;
            margin: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <h1>ğŸ° ì„± ë°©ì–´ ê²Œì„</h1>
    
    <div class="instructions">
        <p><strong>ğŸ® ê²Œì„ ë°©ë²•:</strong></p>
        <p>ì ë“¤ì´ ì„±ì— ë„ë‹¬í•˜ê¸° ì „ì— íƒ€ì›Œë¥¼ ì„¤ì¹˜í•´ì„œ ë§‰ìœ¼ì„¸ìš”!</p>
        <p>íƒ€ì›Œë¥¼ ì„ íƒí•˜ê³  ë§µì— í´ë¦­í•´ì„œ ì„¤ì¹˜í•˜ì„¸ìš”!</p>
        <p>ê° íƒ€ì›Œë§ˆë‹¤ ë‹¤ë¥¸ ëŠ¥ë ¥ì´ ìˆì–´ìš”!</p>
        <p>ğŸ’– ë¹„ë°€: "ì„œë¯¼ì¬ì‚¬ë‘í•´"ë¥¼ ì…ë ¥í•˜ë©´ íŠ¹ë³„í•œ ì¼ì´...?</p>
    </div>
    
    <div class="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div class="game-info">
            <div class="info-item">ì²´ë ¥: <span id="health">100</span></div>
            <div class="info-item">ê³¨ë“œ: <span id="gold">100</span></div>
            <div class="info-item">ì›¨ì´ë¸Œ: <span id="wave">1</span></div>
            <div class="info-item">ì  ìˆ˜: <span id="enemies">0</span></div>
            
            <div class="tower-buttons">
                <button class="tower-btn" onclick="selectTower('basic')">ğŸ¹ ê¸°ë³¸ (10G)</button>
                <button class="tower-btn" onclick="selectTower('cannon')">ğŸ’£ ëŒ€í¬ (25G)</button>
                <button class="tower-btn" onclick="selectTower('ice')">â„ï¸ ì–¼ìŒ (20G)</button>
                <button class="tower-btn" onclick="selectTower('lightning')">âš¡ ë²ˆê°œ (30G)</button>
            </div>
            
            <div id="secretMessage">
                ğŸ’– ë¹„ë°€ ì•”í˜¸ í™œì„±í™”!<br>ë¬´í•œ ê³¨ë“œ ëª¨ë“œ ON! ğŸ’–
            </div>
            
            <button onclick="startWave()">ì›¨ì´ë¸Œ ì‹œì‘</button>
            <button onclick="resetGame()">ìƒˆ ê²Œì„</button>
        </div>
    </div>

    <script>
        // ìº”ë²„ìŠ¤ ì„¤ì •
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // ê²Œì„ ìƒíƒœ
        let gameRunning = false;
        let health = 100;
        let gold = 100;
        let wave = 1;
        let selectedTowerType = null;
        
        // ë¹„ë°€ ì•”í˜¸ ê´€ë ¨ ë³€ìˆ˜
        let secretMode = false;
        let secretInput = '';
        const secretPassword = 'ì„œë¯¼ì¬ì‚¬ë‘í•´';
        
        // ê²½ë¡œ ì„¤ì •
        const path = [
            {x: 0, y: 300},
            {x: 200, y: 300},
            {x: 200, y: 150},
            {x: 400, y: 150},
            {x: 400, y: 450},
            {x: 600, y: 450},
            {x: 600, y: 300},
            {x: 800, y: 300}
        ];
        
        // ê²Œì„ ê°ì²´ë“¤
        let towers = [];
        let enemies = [];
        let projectiles = [];
        let particles = [];
        
        // íƒ€ì›Œ íƒ€ì…ë“¤
        const towerTypes = {
            basic: { cost: 10, damage: 20, range: 80, speed: 1000, color: '#8b4513', projectileColor: '#ff6b6b' },
            cannon: { cost: 25, damage: 50, range: 100, speed: 1500, color: '#2c3e50', projectileColor: '#e74c3c' },
            ice: { cost: 20, damage: 15, range: 90, speed: 800, color: '#3498db', projectileColor: '#74b9ff', slow: true },
            lightning: { cost: 30, damage: 80, range: 120, speed: 2000, color: '#f39c12', projectileColor: '#ffd700', chain: true }
        };
        
        // ì  í´ë˜ìŠ¤
        class Enemy {
            constructor(type, wave) {
                this.type = type;
                this.maxHealth = 50 + wave * 10;
                this.health = this.maxHealth;
                this.speed = 1 + wave * 0.1;
                this.reward = 5 + wave;
                this.pathIndex = 0;
                this.x = path[0].x;
                this.y = path[0].y;
                this.slowEffect = 0;
                this.color = this.getColor();
            }
            
            getColor() {
                const colors = ['#e74c3c', '#9b59b6', '#3498db', '#e67e22', '#1abc9c'];
                return colors[this.type % colors.length];
            }
            
            update() {
                if (this.pathIndex < path.length - 1) {
                    const target = path[this.pathIndex + 1];
                    const dx = target.x - this.x;
                    const dy = target.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 5) {
                        this.pathIndex++;
                    } else {
                        const currentSpeed = this.slowEffect > 0 ? this.speed * 0.5 : this.speed;
                        this.x += (dx / distance) * currentSpeed;
                        this.y += (dy / distance) * currentSpeed;
                    }
                    
                    if (this.slowEffect > 0) this.slowEffect--;
                } else {
                    // ì„±ì— ë„ë‹¬
                    health -= 10;
                    return false;
                }
                
                return this.health > 0;
            }
            
            takeDamage(damage, slowEffect = false) {
                this.health -= damage;
                if (slowEffect) {
                    this.slowEffect = 60; // 1ì´ˆê°„ ëŠë ¤ì§
                }
                
                if (this.health <= 0) {
                    gold += secretMode ? this.reward * 2 : this.reward;
                    createDeathParticles(this.x, this.y);
                    return true;
                }
                return false;
            }
            
            draw() {
                // ì  ëª¸ì²´
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // ì²´ë ¥ë°”
                const barWidth = 30;
                const barHeight = 4;
                const healthPercent = this.health / this.maxHealth;
                
                ctx.fillStyle = '#333';
                ctx.fillRect(this.x - barWidth/2, this.y - 25, barWidth, barHeight);
                
                ctx.fillStyle = healthPercent > 0.5 ? '#2ecc71' : healthPercent > 0.25 ? '#f39c12' : '#e74c3c';
                ctx.fillRect(this.x - barWidth/2, this.y - 25, barWidth * healthPercent, barHeight);
                
                // ìŠ¬ë¡œìš° íš¨ê³¼ í‘œì‹œ
                if (this.slowEffect > 0) {
                    ctx.strokeStyle = '#74b9ff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 18, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        }
        
        // íƒ€ì›Œ í´ë˜ìŠ¤
        class Tower {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.config = towerTypes[type];
                this.lastShot = 0;
                this.target = null;
            }
            
            update() {
                // íƒ€ê²Ÿ ì°¾ê¸°
                this.target = null;
                let closestDistance = this.config.range;
                
                for (let enemy of enemies) {
                    const distance = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                    if (distance < closestDistance) {
                        this.target = enemy;
                        closestDistance = distance;
                    }
                }
                
                // ë°œì‚¬
                if (this.target && Date.now() - this.lastShot > this.config.speed) {
                    this.shoot();
                    this.lastShot = Date.now();
                }
            }
            
            shoot() {
                if (this.type === 'lightning') {
                    // ë²ˆê°œ íƒ€ì›Œ: ì¦‰ì‹œ ë°ë¯¸ì§€
                    this.target.takeDamage(this.config.damage);
                    createLightningEffect(this.x, this.y, this.target.x, this.target.y);
                    
                    // ì²´ì¸ ë¼ì´íŠ¸ë‹
                    if (this.config.chain) {
                        for (let enemy of enemies) {
                            if (enemy !== this.target) {
                                const distance = Math.sqrt((enemy.x - this.target.x)**2 + (enemy.y - this.target.y)**2);
                                if (distance < 60) {
                                    enemy.takeDamage(this.config.damage * 0.5);
                                    createLightningEffect(this.target.x, this.target.y, enemy.x, enemy.y);
                                }
                            }
                        }
                    }
                } else {
                    // ì¼ë°˜ ë°œì‚¬ì²´
                    projectiles.push(new Projectile(this.x, this.y, this.target, this.config));
                }
            }
            
            draw() {
                // íƒ€ì›Œ ë² ì´ìŠ¤
                ctx.fillStyle = this.config.color;
                ctx.fillRect(this.x - 15, this.y - 15, 30, 30);
                
                // íƒ€ì›Œ í¬íƒ‘
                ctx.fillStyle = '#34495e';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // ì‚¬ê±°ë¦¬ í‘œì‹œ (ì„ íƒëœ íƒ€ì›Œë§Œ)
                if (selectedTowerType && this.type === selectedTowerType) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.config.range, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }
        
        // ë°œì‚¬ì²´ í´ë˜ìŠ¤
        class Projectile {
            constructor(x, y, target, config) {
                this.x = x;
                this.y = y;
                this.target = target;
                this.config = config;
                this.speed = 5;
            }
            
            update() {
                if (!this.target || this.target.health <= 0) {
                    return false;
                }
                
                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 10) {
                    // íƒ€ê²Ÿì— ë„ë‹¬
                    const killed = this.target.takeDamage(this.config.damage, this.config.slow);
                    if (killed) {
                        enemies = enemies.filter(e => e !== this.target);
                    }
                    return false;
                } else {
                    this.x += (dx / distance) * this.speed;
                    this.y += (dy / distance) * this.speed;
                    return true;
                }
            }
            
            draw() {
                ctx.fillStyle = this.config.projectileColor;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // íŒŒí‹°í´ íš¨ê³¼
        function createDeathParticles(x, y) {
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: 30,
                    color: secretMode ? '#ffd700' : '#ff6b6b'
                });
            }
        }
        
        function createLightningEffect(x1, y1, x2, y2) {
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            
            // ì§€ê·¸ì¬ê·¸ ë²ˆê°œ íš¨ê³¼
            const steps = 5;
            for (let i = 1; i <= steps; i++) {
                const progress = i / steps;
                const x = x1 + (x2 - x1) * progress + (Math.random() - 0.5) * 20;
                const y = y1 + (y2 - y1) * progress + (Math.random() - 0.5) * 20;
                ctx.lineTo(x, y);
            }
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }
        
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;
                p.life--;
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }
        
        // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸
        canvas.addEventListener('click', (e) => {
            if (!selectedTowerType) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // ê²½ë¡œì™€ ë‹¤ë¥¸ íƒ€ì›Œì™€ ê²¹ì¹˜ì§€ ì•ŠëŠ”ì§€ í™•ì¸
            let canPlace = true;
            
            // ê²½ë¡œ í™•ì¸
            for (let point of path) {
                if (Math.sqrt((x - point.x)**2 + (y - point.y)**2) < 40) {
                    canPlace = false;
                    break;
                }
            }
            
            // ë‹¤ë¥¸ íƒ€ì›Œ í™•ì¸
            for (let tower of towers) {
                if (Math.sqrt((x - tower.x)**2 + (y - tower.y)**2) < 40) {
                    canPlace = false;
                    break;
                }
            }
            
            // íƒ€ì›Œ ì„¤ì¹˜
            if (canPlace) {
                const cost = towerTypes[selectedTowerType].cost;
                if (secretMode || gold >= cost) {
                    if (!secretMode) gold -= cost;
                    towers.push(new Tower(x, y, selectedTowerType));
                    updateDisplay();
                }
            }
        });
        
        // í‚¤ë³´ë“œ ì´ë²¤íŠ¸ (ë¹„ë°€ ì•”í˜¸)
        document.addEventListener('keydown', (e) => {
            if (e.key.length === 1) {
                secretInput += e.key;
                if (secretInput.length > secretPassword.length) {
                    secretInput = secretInput.slice(-secretPassword.length);
                }
                
                if (secretInput === secretPassword) {
                    secretMode = !secretMode;
                    document.getElementById('secretMessage').style.display = secretMode ? 'block' : 'none';
                    secretInput = '';
                    
                    if (secretMode) {
                        gold = 9999; // ë¬´í•œ ê³¨ë“œ
                        updateDisplay();
                    }
                }
            }
        });
        
        function selectTower(type) {
            selectedTowerType = selectedTowerType === type ? null : type;
            
            // ë²„íŠ¼ ìŠ¤íƒ€ì¼ ì—…ë°ì´íŠ¸
            document.querySelectorAll('.tower-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            
            if (selectedTowerType) {
                event.target.classList.add('selected');
            }
        }
        
        function startWave() {
            if (gameRunning) return;
            
            gameRunning = true;
            const enemyCount = 5 + wave * 2;
            
            for (let i = 0; i < enemyCount; i++) {
                setTimeout(() => {
                    enemies.push(new Enemy(i % 3, wave));
                }, i * 1000);
            }
        }
        
        function updateDisplay() {
            document.getElementById('health').textContent = health;
            document.getElementById('gold').textContent = gold;
            document.getElementById('wave').textContent = wave;
            document.getElementById('enemies').textContent = enemies.length;
        }
        
        function resetGame() {
            health = 100;
            gold = 100;
            wave = 1;
            gameRunning = false;
            selectedTowerType = null;
            
            towers = [];
            enemies = [];
            projectiles = [];
            particles = [];
            
            updateDisplay();
            
            document.querySelectorAll('.tower-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
        }
        
        function checkWaveComplete() {
            if (gameRunning && enemies.length === 0) {
                gameRunning = false;
                wave++;
                gold += 20; // ì›¨ì´ë¸Œ ì™„ë£Œ ë³´ë„ˆìŠ¤
                updateDisplay();
            }
        }
        
        function draw() {
            // ë°°ê²½ ê·¸ë¦¬ê¸°
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, secretMode ? '#1a1a2e' : '#87CEEB');
            gradient.addColorStop(1, secretMode ? '#16213e' : '#90EE90');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ê²½ë¡œ ê·¸ë¦¬ê¸°
            ctx.strokeStyle = secretMode ? '#ffd700' : '#8b4513';
            ctx.lineWidth = 20;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(path[i].x, path[i].y);
            }
            ctx.stroke();
            
            // ì„± ê·¸ë¦¬ê¸°
            const castleX = path[path.length - 1].x - 50;
            const castleY = path[path.length - 1].y - 40;
            
            ctx.fillStyle = secretMode ? '#ff6b6b' : '#7f8c8d';
            ctx.fillRect(castleX, castleY, 100, 80);
            
            // ì„± íƒ‘ë“¤
            ctx.fillStyle = secretMode ? '#e74c3c' : '#95a5a6';
            ctx.fillRect(castleX - 10, castleY - 20, 30, 40);
            ctx.fillRect(castleX + 80, castleY - 20, 30, 40);
            ctx.fillRect(castleX + 35, castleY - 30, 30, 50);
            
            // íƒ€ì›Œë“¤ ê·¸ë¦¬ê¸°
            for (let tower of towers) {
                tower.draw();
            }
            
            // ì ë“¤ ê·¸ë¦¬ê¸°
            for (let enemy of enemies) {
                enemy.draw();
            }
            
            // ë°œì‚¬ì²´ë“¤ ê·¸ë¦¬ê¸°
            for (let projectile of projectiles) {
                projectile.draw();
            }
            
            // íŒŒí‹°í´ ê·¸ë¦¬ê¸°
            for (let p of particles) {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 30;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            
            // ê²Œì„ ì˜¤ë²„ í™”ë©´
            if (health <= 0) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#fff';
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ê²Œì„ ì˜¤ë²„!', canvas.width/2, canvas.height/2 - 50);
                
                ctx.font = '24px Arial';
                ctx.fillText(`ì›¨ì´ë¸Œ ${wave}ê¹Œì§€ ë„ë‹¬!`, canvas.width/2, canvas.height/2);
            }
        }
        
        function gameLoop() {
            if (health > 0) {
                // íƒ€ì›Œë“¤ ì—…ë°ì´íŠ¸
                for (let tower of towers) {
                    tower.update();
                }
                
                // ì ë“¤ ì—…ë°ì´íŠ¸
                for (let i = enemies.length - 1; i >= 0; i--) {
                    if (!enemies[i].update()) {
                        enemies.splice(i, 1);
                    }
                }
                
                // ë°œì‚¬ì²´ë“¤ ì—…ë°ì´íŠ¸
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    if (!projectiles[i].update()) {
                        projectiles.splice(i, 1);
                    }
                }
                
                updateParticles();
                checkWaveComplete();
                updateDisplay();
            }
            
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // ê²Œì„ ì‹œì‘
        updateDisplay();
        gameLoop();
    </script>
</body>
</html>